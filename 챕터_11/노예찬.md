11장에서는 10장에서 다루었던 두가지 리팩터링 기법을 응용하는 방법에 대해서 더욱 구체적인 예시로 살펴본다. 그런 다음, 함수 본문을 콜백으로 드러내기에서 발생할 수 있는 또 다른 중복의 문제를 어떻게 해결할 수 있는지를 소개한다.

두 가지 리팩터링 기법을 응용하는 방법에 대해 설명하는 부분은 반복되는 내용이기 때문에, 특별히 요약-정리할 부분이 없다고 생각되었다.

## 함수 본문을 콜백으로 드러내기에서 발생한 중복의 문제를 해결하기 - function factory

책에서는 예시를 설명하기 위해 로깅 동작을 소개한다. 특정한 함수의 동작에서 에러가 발생할 경우 에러 로깅을 하길 원한다고 할 때, 해당 동작을 함수 본문을 콜백으로 드러내기 기법을 이용해서, 조금 더 추상화된 함수로 뽑아낼 수 있다.

하지만, 여기서 발생할 수 있는 문제점은 언제나 해당 함수를 호출할 때, 같이 호출해야한다는 것이다.

```
withLogging(eat)
withLogging(clean)
withLogging(running)
```

로깅 동작을 추상화해서 반복을 줄였다는 점에서는 좋지만, 또 다른 중복이 발생하고 있다.

이 부분을 해결하기 위해서는 function factory 기법을 이용할 수 있다. 이 기법은 특정한 동작을 하는 함수를 만들어내는 함수이다.

우리의 예시에서는 본래 함수의 동작에서, 로깅동작을 추가한 함수를 만들어내는 함수라고 보면 된다.

```js
const wrapLogging = f => arg => {
  try {
    f(arg);
  } catch (error) {
    logToSnapErrors(error);
  }
};
```

위의 함수를 보면, f함수를 인자로 받으면, arg라는 인자를 받았을 때, f 함수와 함께 호출하는 함수를 반환하고 있다. 함수를 반환하는 함수인 것이다. 이런 함수를 만들어두면,

```js
const eatWithLogging = wrapLogging(eat);
const cleanWithLogging = wrapLogging(clean);
const runningWithLogging = wrapLogging(running);

// 이렇게 호출할 수 있다.
eatWithLogging(돈까스);
cleanWithLogging(접시);
```

이런 식으로 에러로깅 동작이 포함된 함수를 만들 수 있다.

마지막으로 살펴본 기법은 커링 기법과 다를 바가 없는 기법이라고 생각된다. 단지 커링 기법은 인자를 하나의 인자로 받게 만들도록 강제한다는 측면이 있을 뿐인 것 같다.

### function factory에서 드러난 일급의 개념

역시나 마지막으로 소개된 기법에서도 일급의 개념이 드러나있다. 왜냐하면 값이 아니라면 함수에서 return할 수 없기 때문이다. 살펴본 기법에서는 함수를 return하고 있는데, 이것 또한 함수가 일급이기 때문에 가능한 동작이다.

---

10장 11장에서는 일급의 개념을 소개하고 있다. 그리고 일급의 개념이 왜 중요한지, 그것을 어떤 방식으로 적용해나갈 수 있는지 여러 기법들을 설명한다.

일급의 개념이 중요한 이유는 값으로 다룰 수 없었던 것들을 값으로 다룰 수 있게 되면서 훨씬 더 유연한 시스템을 만들어나갈 수 있게 되기 때문이다. 그리고 이런 유연한 시스템을 구현하기 위해 일급의 개념을 사용한 기법으로는 암묵적 인자를 드러내기, 함수 본문을 콜백으로 바꾸기, 함수 팩토리 등이 있다.

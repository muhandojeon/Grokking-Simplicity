13장에서는 함수형에서 배열을 다루는 방법에 대해서 살펴보았다. 이번 장에서는 함수형에서 객체를 다루는 방법에 대해서 살펴본다. 특히 중첩된 객체 데이터를 어떻게 다룰 것인지, 그러한 함수형 도구에는 무엇이 있는지를 살펴보려 한다.

---

## 14장의 흐름

14장의 흐름을 정리해보겠다.

1. 객체의 특정 내용을 변경하는 함수가 여럿있다.
2. 객체의 내용을 설정하는 이런 함수들을 추상화하면 update라는 함수를 만들 수 있다.
3. 여기까지는 좋았는데, 중첩된 객체가 나오기 시작했다. 중첩된 객체의 내용을 변경하기 위해 update를 중첩해서 호출하는 방법을 보여준다. update2, update3, ... updateN 과 같은 방식으로..
4. 그런데 update를 중첩해서 호출하는 방법에도 문제가 있었으니, 바로 함수 이름에 있는 암묵적 인자라는 냄새가 난다는 것이다.
5. 이것을 해결하는 방법으로 nestedUpdate라는 함수를 사용할 수 있다.
6. nestedUpdate라는 함수를 구현하기 위해서는 재귀함수가 필요하기에, 재귀함수에 대해서 설명한다.
7. nestedUpdate를 통해서 중첩된 객체의 데이터를 깔끔하게 설정할 수 있게 되었다. 하지만, 여기에도 문제는 있다. 객체의 깊이가 깊을수록 개발자가 기억해야 할 객체의 구조가 많다는 것이다.
8. 이런 경우에는 nestedUpdate를 이용하기 보다는 직접 구현 패턴을 이용해, 추상화 벽을 세우는 것이 더욱 간결하고 명확한 코드를 만들 수 있게 된다.

결국 14장의 흐름을 다시 정리하면,

- 문제1 (객체 변경 함수 중복) -> 해결방안1 (update 함수)
- 문제2 (중첩된 객체) -> 해결 방안2 (update함수 중첩호출)
- 문제3 (중첩 update함수의 냄새) -> 해결 방안3 (nestedUpdate) -> 부연설명(재귀호출)
- 문제4 (nestedUpdate의 인지적 과부화) -> 해결방안4 (추상화벽)

4번의 문제와 4번의 해결방안을 소개하는 것으로 이루어져 있다.

## 14장에서 얻을 수 있는 것

- 객체를 다룰 때 사용할 수 있는 함수형 도구 => update
- 중첩된 객체를 다룰 때 사용할 수 있는 함수형 도구 => nestedUpdate
- nestedUpdate로 인지적 과부화가 올 때 적용할 수 있는 패턴 => 추상화 벽
- update, nestedUpdate가 만들어지는 과정.

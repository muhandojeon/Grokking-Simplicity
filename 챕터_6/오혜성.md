# 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

## 동작의 읽기, 쓰기

* 동작을 읽기, 쓰기 또는 둘 다로 분류할 수 있음
  + 읽기는 데이터를 바꾸지 않고 정보를 꺼내는 것
  + 쓰기는 데이터를 바꾸는 것
    - 쓰기 동작을 불변성 원칙에 따라 구현해야 함
      - 여기에서 불변성 원칙은 카피 온 라이트

* 카피 온 라이트는 쓰기를 읽기로 바꿈

```
1. 복사본 만들기
2. 복사본 변경하기
3. 복사본 리턴하기
```

## 쓰기와 읽기를 같이 한다면?

* shift 같은 메서드

* 두 가지 접근 방법이 있음
  + 함수를 분리하기
  + 값을 두 개 리턴하기

```js
// .shift 라면

function first_elem(arr) {
    return arr[0];
}

function drop_first(arr) {
    arr.shift(); // 하지만 이것은 쓰기이니

    // 이렇게 할 수 있음
    var arr_copy = arr.slice(); // 복사본 만들기
    arr_copy.shift(); // 복사본 변경하기
    return arr_copy; // 복사본 리턴하기
}
```

## 불변 데이터 구조를 읽는 것은 계산

* 변경 가능한 데이터를 읽는 것은 액션

* 어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터
  + 불변 데이터 구조를 읽는 것은 계산

* 쓰기를 읽기로 바꾸면 코드에 계산이 많아짐

## 불변 데이터 구조는 충분히 빠르다

* 언제든 최적화할 수 있다
  + 속도가 느린 부분이 있다면 그때 최적화하기
* 가비지 콜렉터는 매우 빠름
  > 시대적 가설
* 생각보다 많이 복사하지 않음
  + 얕은 복사를 하기 때문에
* 함수형 프로그래밍 언어에는 빠른 구현체가 있음

## 객체에 대한 카피 온 라이트

```js
Object.assign({}, obj);
```

* 얕은 복사를 통해 참조가 공유되고, 이는 `구조적 공유`라고 함
  + 데이터가 바뀌지 않는한 구조적 공유는 안전함
  + 구조적 공유는 메모리를 적게 사용하고, 모든 것을 복사하는 것보다 빠름

